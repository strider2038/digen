// Code generated by DIGEN; DO NOT EDIT.
// This file was generated by Dependency Injection Container Generator (unknown version).
// See docs at https://github.com/strider2038/digen
package internal

import (
	"context"
	"errors"
	factories "example.com/test/di/internal/factories"
	"fmt"
	"net/url"
	"time"
)

const (
	id_StringOption = iota
	id_StringPointer
	id_IntOption
	id_TimeOption
	id_DurationOption
	id_URLOption
	id_IntSlice
	id_StringMap
)

type Container struct {
	errs []error
	init bitset

	stringOption   string
	stringPointer  *string
	intOption      int
	timeOption     time.Time
	durationOption time.Duration
	urloption      url.URL
	intSlice       []int
	stringMap      map[string]string
}

func NewContainer() *Container {
	c := &Container{}
	c.init = make(bitset, 1)

	return c
}

// Error returns the first initialization error, which can be set via SetError in a service definition.
func (c *Container) Error() error {
	return errors.Join(c.errs...)
}

// SetError sets the first error into container. The error is used in the public container to return an initialization error.
// Deprecated. Return error in factory instead.
func (c *Container) SetError(err error) {
	c.addError(err)
}

func (c *Container) addError(err error) {
	if err != nil {
		c.errs = append(c.errs, err)
	}
}

func (c *Container) StringOption(ctx context.Context) string {
	if !c.init.IsSet(id_StringOption) && c.errs == nil {
		var err error
		c.stringOption, err = factories.CreateStringOption(ctx, c)
		if err != nil {
			c.addError(fmt.Errorf("create StringOption: %w", err))
		}
		c.init.Set(id_StringOption)
	}
	return c.stringOption
}

func (c *Container) StringPointer(ctx context.Context) *string {
	if !c.init.IsSet(id_StringPointer) && c.errs == nil {
		var err error
		c.stringPointer, err = factories.CreateStringPointer(ctx, c)
		if err != nil {
			c.addError(fmt.Errorf("create StringPointer: %w", err))
		}
		c.init.Set(id_StringPointer)
	}
	return c.stringPointer
}

func (c *Container) IntOption(ctx context.Context) int {
	if !c.init.IsSet(id_IntOption) && c.errs == nil {
		var err error
		c.intOption, err = factories.CreateIntOption(ctx, c)
		if err != nil {
			c.addError(fmt.Errorf("create IntOption: %w", err))
		}
		c.init.Set(id_IntOption)
	}
	return c.intOption
}

func (c *Container) TimeOption(ctx context.Context) time.Time {
	if !c.init.IsSet(id_TimeOption) && c.errs == nil {
		var err error
		c.timeOption, err = factories.CreateTimeOption(ctx, c)
		if err != nil {
			c.addError(fmt.Errorf("create TimeOption: %w", err))
		}
		c.init.Set(id_TimeOption)
	}
	return c.timeOption
}

func (c *Container) DurationOption(ctx context.Context) time.Duration {
	if !c.init.IsSet(id_DurationOption) && c.errs == nil {
		var err error
		c.durationOption, err = factories.CreateDurationOption(ctx, c)
		if err != nil {
			c.addError(fmt.Errorf("create DurationOption: %w", err))
		}
		c.init.Set(id_DurationOption)
	}
	return c.durationOption
}

func (c *Container) URLOption(ctx context.Context) url.URL {
	if !c.init.IsSet(id_URLOption) && c.errs == nil {
		var err error
		c.urloption, err = factories.CreateURLOption(ctx, c)
		if err != nil {
			c.addError(fmt.Errorf("create URLOption: %w", err))
		}
		c.init.Set(id_URLOption)
	}
	return c.urloption
}

func (c *Container) IntSlice(ctx context.Context) []int {
	if !c.init.IsSet(id_IntSlice) && c.errs == nil {
		var err error
		c.intSlice, err = factories.CreateIntSlice(ctx, c)
		if err != nil {
			c.addError(fmt.Errorf("create IntSlice: %w", err))
		}
		c.init.Set(id_IntSlice)
	}
	return c.intSlice
}

func (c *Container) StringMap(ctx context.Context) map[string]string {
	if !c.init.IsSet(id_StringMap) && c.errs == nil {
		var err error
		c.stringMap, err = factories.CreateStringMap(ctx, c)
		if err != nil {
			c.addError(fmt.Errorf("create StringMap: %w", err))
		}
		c.init.Set(id_StringMap)
	}
	return c.stringMap
}

func (c *Container) Close() {}
